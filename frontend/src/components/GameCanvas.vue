<template>
  <div style="flex: 1; display: flex; flex-direction: column">
    <canvas
      ref="canvas"
      style="flex: 1; background: #f6f8fa; touch-action: none"
    ></canvas>

    <div style="padding: 8px; display: flex; gap: 8px; justify-content: center; flex-wrap: wrap; border-top: 1px solid #e5e7eb;">
      <label style="display:flex; align-items:center; gap:6px">
        难度
        <select v-model="difficulty" @change="onChangeDifficulty" style="padding:6px; border-radius:6px; border:1px solid #cbd5e1">
          <option value="easy">简单</option>
          <option value="medium">中等</option>
          <option value="hard">困难</option>
        </select>
      </label>
      <span style="display:flex; align-items:center">关卡 {{ levelIndex }}</span>
      <button @click="prevLevel">上一关</button>
      <button @click="nextLevel">下一关</button>
      <div style="display:flex; gap:8px; align-items:center; white-space:nowrap;">
        <button @click="undoStep">后退</button>
        <button @click="askSolve">提示</button>
        <button @click="reset">重新游戏</button>
      </div>
      <!-- <button @click="loadDemo">加载示例</button> -->
    </div>

    <div v-if="message" style="padding:8px; text-align:center; color:#0b7a00; font-weight:600;">
      {{ message }}
    </div>
  </div>
</template>

<script setup>
import { ref, onMounted, onBeforeUnmount } from "vue";
import { fetchDemo, fetchLevel, solveGraph } from "../api/fastapi";

const canvas = ref(null);
let ctx = null;
let nodes = [];
let edges = [];
let visitedEdges = [];
let currentNode = null;
let pathEndpoint = null;
let fullSolutionPath = [];
let hintInvalidated = false; // Simplified: No hintStepIndex needed for full solve

const difficulty = ref("easy");
const levelIndex = ref(1);
const message = ref("");

function edgeKey(a, b) {
  return a < b ? `${a}-${b}` : `${b}-${a}`;
}

function layoutNodesCircle(ids) {
  const el = canvas.value;
  if (!el || !el.width || !el.height || el.width <= 0 || el.height <= 0) {
    return [];
  }
  const cx = el.width / 2;
  const cy = el.height / 2;
  const r = Math.max(60, Math.min(el.width, el.height) / 2 - 50);
  const count = ids.length || 1;
  return ids.map((id, i) => {
    const ang = (i / count) * Math.PI * 2 - Math.PI / 2;
    const x = cx + r * Math.cos(ang);
    const y = cy + r * Math.sin(ang);
    return { id, x, y };
  });
}
const PATH_COLORS = [
    "#E91E63", // 1. 粉红 (深)
    "#00BCD4", // 2. 青色
    "#FF9800", // 3. 橙色
    "#4CAF50", // 4. 绿色
    "#673AB7", // 5. 深紫
    "#FFEB3B", // 6. 黄色 (需谨慎，在浅色背景上可能看不清)
    "#03A9F4", // 7. 浅蓝
    "#795548", // 8. 棕色
    "#607D8B", // 9. 蓝灰
    "#F44336", // 10. 红色
    "#009688", // 11. 蓝绿
    "#9C27B0", // 12. 紫色
    "#CDDC39", // 13. 浅绿
    "#FF5722", // 14. 深橙
    "#8BC34A", // 15. 橄榄绿
    "#00796B", // 16. 深青
    "#AFB42B", // 17. 泥黄
    "#7B1FA2", // 18. 靛紫
    "#C2185B", // 19. 玫瑰红
    "#00579C", // 20. 深蓝
];
const UNVISITED_COLOR = "#cbd5e1";
const NODE_STROKE_COLOR = "#333";
const NODE_FILL_COLOR = "#fff";

function draw() {
    if (!ctx) return;
    ctx.clearRect(0, 0, canvas.value.width, canvas.value.height);

    // --- 辅助代码 (确保边线不画到圆心，并定义半径) ---
    const nodeRadius = 18; 

    const getPointOnCircumference = (na, nb, radius) => {
        const angle = Math.atan2(nb.y - na.y, nb.x - na.x);
        const x = na.x + radius * Math.cos(angle);
        const y = na.y + radius * Math.sin(angle);
        return { x, y };
    };
    // ----------------------------------------------------

    ctx.lineWidth = 6;
    edges.forEach(([a, b]) => {
        const na = nodes.find((n) => n.id === a);
        const nb = nodes.find((n) => n.id === b);
        const key = edgeKey(a, b);
        if (!na || !nb) return;

        // 边线不画到圆心 (保持之前修改的正确逻辑)
        const startPoint = getPointOnCircumference(na, nb, nodeRadius);
        const endPoint = getPointOnCircumference(nb, na, nodeRadius);

        ctx.beginPath();
        ctx.moveTo(startPoint.x, startPoint.y);
        ctx.lineTo(endPoint.x, endPoint.y);
        
        // 原版颜色逻辑：检查边是否被访问，如果是，使用蓝色，否则使用灰色
        ctx.strokeStyle = visitedEdges.find(v => v.key === key) ? "#0b84ff" : "#cbd5e1";
        ctx.stroke();
    });

    nodes.forEach((n) => {
        ctx.beginPath();
        ctx.arc(n.x, n.y, nodeRadius, 0, Math.PI * 2); // 使用 nodeRadius
        ctx.fillStyle = "#fff";
        ctx.fill();
        ctx.strokeStyle = "#333";
        ctx.lineWidth = 2;
        ctx.stroke();
    });

    visitedEdges.forEach((visited, index) => {
        const seqNum = index + 1;
        const { from, to } = visited;
        const na = nodes.find((n) => n.id === from);
        const nb = nodes.find((n) => n.id === to);
        if (!na || !nb) return;

        // --- 恢复核心逻辑：获取独特的颜色（解决 ReferenceError） ---
        const pathColor = PATH_COLORS[index % PATH_COLORS.length];
        // -----------------------------------------------------------
        
        // 重新绘制已访问的边，以确保颜色覆盖（并使用不画入圆心的点）
        const startPoint = getPointOnCircumference(na, nb, nodeRadius);
        const endPoint = getPointOnCircumference(nb, na, nodeRadius);
        ctx.lineWidth = 6;
        ctx.beginPath();
        ctx.moveTo(startPoint.x, startPoint.y);
        ctx.lineTo(endPoint.x, endPoint.y);
        ctx.strokeStyle = pathColor; // 使用独特的颜色
        ctx.stroke();

        // ------------------------------------------------------
        // --- 核心改动：计算序号位置，使其靠近箭头 (只改动这里) ---
        // ------------------------------------------------------
        const offsetDistance = 15; // 垂直偏移量
        const backOffset = 30;     // 沿着边的反方向回退的距离

        let vecX = nb.x - na.x; // 向量 from A to B
        let vecY = nb.y - na.y;
        const len = Math.hypot(vecX, vecY);
        let normX = 0; 
        let normY = 0; 
        
        if (len > 0) { 
            // 归一化法线向量 (用于垂直偏移)
            normX = -vecY / len; 
            normY = vecX / len; 
            
            // 归一化方向向量 (用于沿着边回退)
            vecX /= len;
            vecY /= len;
        }
        
        // 1. 找到箭头终点（在 nb 节点的圆周上）
        const angle = Math.atan2(nb.y - na.y, nb.x - na.x);
        const arrowX = nb.x - nodeRadius * Math.cos(angle);
        const arrowY = nb.y - nodeRadius * Math.sin(angle);
        
        // 2. 从箭头终点向后退 backOffset 的距离
        const backX = arrowX - vecX * backOffset;
        const backY = arrowY - vecY * backOffset;
        
        // 3. 在回退后的点上，进行垂直于边线的偏移
        const numX = backX + normX * offsetDistance;
        const numY = backY + normY * offsetDistance;
        // ------------------------------------------------------
        
        ctx.fillStyle = pathColor; // 序号文本使用独特的颜色
        ctx.font = "bold 15px Arial";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText(seqNum.toString(), numX, numY);

        // --- 恢复箭头绘制逻辑（使用 pathColor） ---
        const arrowLength = 12;
        const arrowAngle = Math.PI / 6;
        // angle 变量已在上面计算
        const endX = nb.x - nodeRadius * Math.cos(angle); // 箭头终点
        const endY = nb.y - nodeRadius * Math.sin(angle);
        
        ctx.beginPath();
        ctx.moveTo(endX, endY);
        ctx.lineTo( endX - arrowLength * Math.cos(angle - arrowAngle), endY - arrowLength * Math.sin(angle - arrowAngle));
        ctx.moveTo(endX, endY);
        ctx.lineTo( endX - arrowLength * Math.cos(angle + arrowAngle), endY - arrowLength * Math.sin(angle + arrowAngle));
        ctx.strokeStyle = pathColor; // 箭头使用独特的颜色
        ctx.lineWidth = 3;
        ctx.stroke();
        // ------------------------------------------
    });
}
function reset() {
  visitedEdges.length = 0;
  currentNode = null;
  pathEndpoint = null;
  fullSolutionPath.length = 0;
  hintInvalidated = false;
  message.value = "";
  draw();
}

async function loadDemo() {
  try {
    const res = await fetchDemo();
    fullSolutionPath.length = 0;
    hintInvalidated = false;
    nodes = layoutNodesCircle(res.nodes); // Use Circle for demo
    edges = res.edges;
    reset();
  } catch (err) {
    message.value = "加载示例失败，请检查后端服务。";
  }
}

async function loadCurrentLevel() {
  try {
    const res = await fetchLevel(difficulty.value, levelIndex.value);
    fullSolutionPath.length = 0;
    hintInvalidated = false;
    nodes = layoutNodesCircle(res.nodes); // Use Circle for levels
    edges = res.edges;
    reset();
  } catch (err) {
    message.value = "加载关卡失败，请检查后端服务。";
  }
}

async function askSolve() {
  message.value = "";

  if (fullSolutionPath.length === 0) {
    try {
      const payload = { nodes: nodes.map(n => n.id), edges }; // Prepare payload
      console.log("向后端发送 /solve 请求:", payload); // Log request payload
      const res = await solveGraph(payload);
      console.log("从后端收到 /solve 响应:", res); // Log response

      if (!res.ok || !res.path || res.path.length < 1) { // Path can be length 1 if only 1 node
        message.value = res.error || "无法求解";
        return;
      }
      fullSolutionPath = res.path;
    } catch (err) {
      // --- V V V Added detailed error logging V V V ---
      console.error("求解器调用失败:", err); // Log the actual error object
      if (err.response) {
        console.error("后端响应数据:", err.response.data);
        console.error("后端响应状态:", err.response.status);
      } else if (err.request) {
        console.error("请求已发出但无响应:", err.request);
      } else {
        console.error("请求设置错误:", err.message);
      }
      // --- ^ ^ ^ Logging added ^ ^ ^ ---
      message.value = "提示功能连接失败，请检查后端。";
      return;
    }
  }

  visitedEdges.length = 0;

  // Check if fullSolutionPath is valid before iterating
  if (!fullSolutionPath || fullSolutionPath.length < 1) {
       message.value = "获取的路径无效";
       return;
  }

  // Handle single-node case (no edges to draw)
  if (fullSolutionPath.length == 1) {
       pathEndpoint = fullSolutionPath[0];
       hintInvalidated = true;
       draw(); // Draw just the nodes
       checkComplete(); // Should ideally show success if edges.length is 0
       return;
  }


  for (let i = 0; i < fullSolutionPath.length - 1; i++) {
    const startNode = fullSolutionPath[i];
    const endNode = fullSolutionPath[i+1];
    const key = edgeKey(startNode, endNode);
    visitedEdges.push({ key: key, from: startNode, to: endNode });
  }

  pathEndpoint = fullSolutionPath[fullSolutionPath.length - 1];
  hintInvalidated = true;

  draw();
  checkComplete();
}


function checkComplete() {
  if (edges && edges.length >= 0) { // Allow 0 edges for single node graphs
      let allEdgesVisited = true;
      const visitedCounts = visitedEdges.reduce((acc, v) => {
          acc[v.key] = (acc[v.key] || 0) + 1;
          return acc;
      }, {});

      const totalCounts = edges.reduce((acc, e) => {
           const k = edgeKey(e[0], e[1]);
           acc[k] = (acc[k] || 0) + 1;
           return acc;
      }, {});

      // Check if total edge count matches visited edge count
      if(visitedEdges.length !== edges.length){
           allEdgesVisited = false;
      } else {
           // Verify counts for each unique edge key
           for (const key in totalCounts) {
               if (visitedCounts[key] !== totalCounts[key]) {
                   allEdgesVisited = false;
                   break;
               }
           }
           if (Object.keys(visitedCounts).length !== Object.keys(totalCounts).length) {
               allEdgesVisited = false;
           }
      }


      if (allEdgesVisited) {
          message.value = "🎉 恭喜通关！";
      }
  }
}


function findNodeAt(x, y) {
  return nodes.find((n) => Math.hypot(n.x - x, n.y - y) < 50);
}

function onPointerDown(e) {
  e.preventDefault();
  const t = e.touches ? e.touches[0] : e;
  const rect = canvas.value.getBoundingClientRect();
  const x = t.clientX - rect.left;
  const y = t.clientY - rect.top;
  const n = findNodeAt(x, y);

  if (!n) return;
  message.value = "";

  if (visitedEdges.length === 0) {
      hintInvalidated = true;
  }

  if (visitedEdges.length === 0) {
    currentNode = n.id;
    pathEndpoint = n.id;
  } else if (n.id === pathEndpoint) {
    currentNode = n.id;
  }
}

function onPointerMove(e) {
  if (!currentNode) return;
  e.preventDefault();
  hintInvalidated = true;

  const t = e.touches ? e.touches[0] : e;
  const rect = canvas.value.getBoundingClientRect();
  const x = t.clientX - rect.left;
  const y = t.clientY - rect.top;
  const n = findNodeAt(x, y);

  if (n && n.id !== currentNode) {
    const possible = edges.some(
      ([a, b]) => (a === currentNode && b === n.id) || (a === n.id && b === currentNode)
    );

    if (possible) {
      const k = edgeKey(currentNode, n.id);

      const drawnCount = visitedEdges.filter(v => v.key === k).length;
      const totalCount = edges.filter(e => edgeKey(e[0], e[1]) === k).length;

      if (drawnCount < totalCount) {
        visitedEdges.push({ key: k, from: currentNode, to: n.id });
        currentNode = n.id;
        pathEndpoint = n.id;
        draw();
        checkComplete();
      }
    }
  }
}

function onPointerUp() {
  currentNode = null;
}

function prevLevel() {
  levelIndex.value = Math.max(1, levelIndex.value - 1);
  loadCurrentLevel();
}
function nextLevel() {
  levelIndex.value += 1;
  loadCurrentLevel();
}
// Undo the last drawn step (pop last visited edge)
function undoStep() {
  // Nothing to undo
  if (visitedEdges.length === 0) return;

  // Remove the last visited edge
  visitedEdges.pop();

  // Update endpoint/current node according to remaining path
  if (visitedEdges.length === 0) {
    pathEndpoint = null;
    currentNode = null;
  } else {
    const last = visitedEdges[visitedEdges.length - 1];
    // The last visited edge's 'to' is the current endpoint
    pathEndpoint = last.to;
    currentNode = null;
  }

  hintInvalidated = true;
  message.value = "";
  draw();
}
function onChangeDifficulty() {
  console.log("难度更改为:", difficulty.value);
  levelIndex.value = 1;
  loadCurrentLevel();
}

let resizeHandler = null;

onMounted(() => {
  const el = canvas.value;
  ctx = el.getContext("2d");

  resizeHandler = () => {
    const w = window.innerWidth;
    const h = Math.max(200, window.innerHeight - 112);

    if (el.width !== w || el.height !== h) {
      el.width = w;
      el.height = h;

      if (nodes.length > 0) {
        nodes = layoutNodesCircle(nodes.map(n => n.id));
        draw();
      } else {
        draw();
      }
    } else {
      draw();
    }
  }

  window.addEventListener("resize", resizeHandler);
  resizeHandler();

  el.addEventListener("touchstart", onPointerDown, { passive: false });
  el.addEventListener("touchmove", onPointerMove, { passive: false });
  el.addEventListener("touchend", onPointerUp);
  el.addEventListener("mousedown", onPointerDown);
  el.addEventListener("mousemove", onPointerMove);
  el.addEventListener("mouseup", onPointerUp);
  el.addEventListener("mouseleave", onPointerUp);

  loadCurrentLevel();
});

onBeforeUnmount(() => {
  const el = canvas.value;
  if (el) {
    el.removeEventListener("touchstart", onPointerDown);
    el.removeEventListener("touchmove", onPointerMove);
    el.removeEventListener("touchend", onPointerUp);
    el.removeEventListener("mousedown", onPointerDown);
    el.removeEventListener("mousemove", onPointerMove);
    el.removeEventListener("mouseup", onPointerUp);
    el.removeEventListener("mouseleave", onPointerUp);
  }
  if (resizeHandler) {
    window.removeEventListener("resize", resizeHandler);
  }
});
</script>

<style scoped>
button {
  padding: 8px 12px;
  border-radius: 6px;
  border: 1px solid #cbd5e1;
  background: #fff;
}
select {
  padding: 8px 12px;
  border-radius: 6px;
  border: 1px solid #cbd5e1;
  background: #fff;
}
</style>